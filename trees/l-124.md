# Binary Tree Maximum Path Sum (LeetCode 124)

## Core Concept: Post-Order Traversal (Bottom-Up)
The algorithm uses DFS to process the tree from the bottom up. At every node, we make a decision based on the values returned by its children.

## The Critical Logic: `max(child_sum, 0)`
When a child node returns a path sum, we must decide whether to include that path or ignore it.

* **The Rule:** A negative path sum acts like **"debt"**. If a child offers a negative sum, it reduces the total value of the current path.
* **The Fix:** We clamp negative results to 0. `max(dfs(child), 0)`.
* **Translation:** "If you offer me debt (negative value), I will treat your contribution as 0 (cut the connection)."

---

## Example 1: The "Travel Through" Case (Net Profit)
**Question:** Why do we sometimes include a negative node in the path?
**Answer:** We include a negative node if the "treasure" below it is large enough to pay off the "debt" of the node itself.

### The Tree
```
       10
      /  \
    -20   30
    /  \
  100  500
```

### Execution Steps
1.  **Bottom Nodes:** `100` and `500` return their values.
2.  **Node -20:** Calculates its best path extension:
    * `node.val` + `max(left, right)`
    * `-20` + `500` = **480**
3.  **Root Node 10:** Receives **480** from the left side.
    * It checks `max(480, 0)`. Since 480 is positive, it **keeps** the connection.

### Key Point
Even though the node itself is negative (`-20`), the path including the node is positive (`480`). The **"profit"** from the child (`500`) covered the **"debt"** of the parent (`-20`). Therefore, the algorithm correctly travels through the negative node.

---

## Example 2: The "Cut" Case (Net Loss)
**Question:** When do we stop the path?
**Answer:** When the "treasure" below isn't enough to cover the negative node's cost.

### The Tree
```
       10
      /
    -20
      \
       5   <-- Small treasure
```
### Execution Steps
1.  **Bottom Node:** Returns `5`.
2.  **Node -20:** Calculates its path:
    * `-20` + `5` = **-15**
    * This subtree is in "net debt."
3.  **Root Node 10:** Receives **-15** from the left.
    * It checks `max(-15, 0)`.
    * It converts the value to **0**.
    * **Result:** The path from 10 to -20 is severed.

---

## The Code Implementation

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        
        max_sum = [root.val]

        def _dfs(node):
            if not node:
                return 0
            
            left_sum = max(_dfs(node.left), 0)
            right_sum = max(_dfs(node.right), 0)
            max_sum[0] = max(max_sum[0], node.val + left_sum + right_sum)

            return node.val + max(left_sum, right_sum)

        _dfs(root)
        return max_sum[0]        

```
