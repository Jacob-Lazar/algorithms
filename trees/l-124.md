# Binary Tree Maximum Path Sum (LeetCode 124)

## Core Concept: Post-Order Traversal (Bottom-Up)
The algorithm uses DFS to process the tree from the bottom up. At every node, we make a decision based on the values returned by its children.

## The Critical Logic: `max(child_sum, 0)`
When a child node returns a path sum, we must decide whether to include that path or ignore it.

* **The Rule:** A negative path sum acts like **"debt"**. If a child offers a negative sum, it reduces the total value of the current path.
* **The Fix:** We clamp negative results to 0. `max(dfs(child), 0)`.
* **Translation:** "If you offer me debt (negative value), I will treat your contribution as 0 (cut the connection)."

---

## Example 1: The "Travel Through" Case (Net Profit)
**Question:** Why do we sometimes include a negative node in the path?
**Answer:** We include a negative node if the "treasure" below it is large enough to pay off the "debt" of the node itself.

### The Tree
       10
      /  \
    -20   30
    /  \
  100  500

### Execution Steps
1.  **Bottom Nodes:** `100` and `500` return their values.
2.  **Node -20:** Calculates its best path extension:
    * `node.val` + `max(left, right)`
    * `-20` + `500` = **480**
3.  **Root Node 10:** Receives **480** from the left side.
    * It checks `max(480, 0)`. Since 480 is positive, it **keeps** the connection.

### Key Point
Even though the node itself is negative (`-20`), the path including the node is positive (`480`). The **"profit"** from the child (`500`) covered the **"debt"** of the parent (`-20`). Therefore, the algorithm correctly travels through the negative node.

---

## Example 2: The "Cut" Case (Net Loss)
**Question:** When do we stop the path?
**Answer:** When the "treasure" below isn't enough to cover the negative node's cost.

### The Tree
       10
      /
    -20
      \
       5   <-- Small treasure

### Execution Steps
1.  **Bottom Node:** Returns `5`.
2.  **Node -20:** Calculates its path:
    * `-20` + `5` = **-15**
    * This subtree is in "net debt."
3.  **Root Node 10:** Receives **-15** from the left.
    * It checks `max(-15, 0)`.
    * It converts the value to **0**.
    * **Result:** The path from 10 to -20 is severed.

---

## The Code Implementation

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        
        # Initialize with a very small number (or root.val) to handle 
        # cases where the tree contains only negative numbers.
        max_sum = [float('-inf')]

        def _dfs(node):
            if not node:
                return 0
            
            # 1. RECURSE & CLAMP
            # If a child returns a negative sum, we treat it as 0 (ignore that branch).
            # This is the "Decision to Cut" logic.
            left_sum = max(_dfs(node.left), 0)
            right_sum = max(_dfs(node.right), 0)
            
            # 2. UPDATE GLOBAL MAX (The "Split")
            # Calculate the price of the arch: Left Child + Node + Right Child.
            # This path CANNOT be passed up to the parent.
            max_sum[0] = max(max_sum[0], node.val + left_sum + right_sum)

            # 3. RETURN TO PARENT (The "Path")
            # We can only pass up the node itself + ONE best child (or 0).
            return node.val + max(left_sum, right_sum)

        _dfs(root)
        return max_sum[0]
```
